//////////////////////////////////////////////////////////////////////////////////////////
// VersInfoExShlExt.cpp  --  Implementation of the CVersInfoShlExt class
//////////////////////////////////////////////////////////////////////////////////////////
//
//   Copyright (C) Software Development Laboratories, aka "Fish" (David B. Trout)
//
//   Licensed under terms of the ZLIB/LIBPNG Open Source Software License
//   http://www.opensource.org/licenses/zlib-license.php
//
//   THIS SOFTWARE IS PROVIDED 'AS-IS', WITHOUT ANY EXPRESS OR IMPLIED WARRANTY.
//   IN NO EVENT WILL THE AUTHOR(S) BE HELD LIABLE FOR ANY DAMAGES ARISING FROM
//   THE USE OF THIS SOFTWARE.
//
//   Permission is granted to anyone to use this software for any purpose, including
//   commercial applications, and to alter it and redistribute it freely, subject to
//   the following restrictions:
//
//    1. The origin of this software must not be misrepresented; you must not claim
//       that you wrote the original software. If you use this software in a product,
//       an acknowledgment in the product documentation would be appreciated but is
//       not required.
//
//    2. Altered source versions must be plainly marked as such, and must not be
//       misrepresented as being the original software.
//
//    3. Neither this notice nor the above Copyright information may be removed
//       or altered from any source distribution.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Change History:
//
//  10/13/10    1.0.0   Fish    Created.
//
//////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"                 // (system-wide precompiled headers)
#include "resource.h"               // (our property sheet resource ids)
#include "VersInfoEx.h"             // (auto-generated by MIDL compiler)
#include "VersInfoExShlExt.h"       // (Shell Extension implementation)
#include "CVersInfo.h"              // (our version information parser)

$MODULEID;      // (embed module-id timestamp and copyright string into object code)

//////////////////////////////////////////////////////////////////////////////////////////
// (forward references)

UINT     CALLBACK  PropPageCallbackProc  ( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
INT_PTR  CALLBACK  PropPageDlgProc       ( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
BOOL               OnInitDialog          ( HWND hwnd, LPARAM lParam );

//////////////////////////////////////////////////////////////////////////////////////////
// Shell Extension initialization...

STDMETHODIMP  CVersInfoShlExt::Initialize ( LPCITEMIDLIST pidlFolder, LPDATAOBJECT pDataObj, HKEY hProgID )
{
    // Initialize common controls...

    INITCOMMONCONTROLSEX    iccex  = { sizeof( INITCOMMONCONTROLSEX ), ICC_STANDARD_CLASSES };
    InitCommonControlsEx ( &iccex );

    // Read the list of files from the data object. They're stored in HDROP format
    // so it's simple: just get the HDROP handle and use the drag-and-drop APIs...

    FORMATETC  etc  = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM  stg;

    if (FAILED( pDataObj->GetData( &etc, &stg )))
        return E_INVALIDARG;

    HDROP hdrop = (HDROP) GlobalLock( stg.hGlobal );

    if (!hdrop)
    {
        ReleaseStgMedium( &stg );
        return E_INVALIDARG;
    }

    // Retrieve the selected filename or else fail if more than one was selected...

    HRESULT  hResult        =  S_OK;    // (think positively)
    CString  strFilename;
    LPTSTR   pszFilename;
    UINT     nNameLen;

    if (0
        || DragQueryFile( hdrop, 0xFFFFFFFF, NULL, 0 ) != 1
        || (nNameLen = DragQueryFile( hdrop, 0, NULL, 0 ) + 1) <= 1
        || !(pszFilename = strFilename.GetBuffer( nNameLen + 1 ))
        || !DragQueryFile ( hdrop, 0, pszFilename, nNameLen )
        || PathIsDirectory( pszFilename )
    )
    {
        hResult = E_FAIL;
    }
    else
    {
        strFilename.ReleaseBuffer( nNameLen );

        // (our CVersionInfo class does all our grunt work)

        if (0
            || strFilename.IsEmpty()
            || !(m_pVI = new CVersionInfo( strFilename ))
            || !m_pVI->m_StringTableMap.GetSize() // (no StringTables?!)
            || !m_pVI->m_StringTableMap.GetValueAt(0).m_StringsMap.GetSize() // (no Strings?!)
        )
        {
            if (m_pVI)
            {
                delete m_pVI;   // (prevent memory leak)
                m_pVI = NULL;
            }
            hResult = E_FAIL;
        }
    }

    GlobalUnlock( stg.hGlobal );
    ReleaseStgMedium( &stg );

    return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Create our property page and add it to the Shell's property sheet dialog...

STDMETHODIMP  CVersInfoShlExt::AddPages ( LPFNADDPROPSHEETPAGE pfnAddPageProc, LPARAM lParam )
{
    if (!m_pVI)
        return E_FAIL;

    // Create our property page...

    PROPSHEETPAGE psp;

    ZeroMemory(  &psp,  sizeof( PROPSHEETPAGE ));

    psp.dwSize       =  sizeof( PROPSHEETPAGE );
    psp.dwFlags      =  0
                        | PSP_DEFAULT
                        | PSP_USECALLBACK
                        | PSP_USEREFPARENT
                        ;
    psp.pszTemplate  =  MAKEINTRESOURCE( IDD_VERSINFOEX_PROPPAGE );
    psp.hInstance    =  _Module.GetResourceInstance();
    psp.pcRefParent  =  (UINT*) &_Module.m_nLockCnt;
    psp.pfnDlgProc   =  PropPageDlgProc;
    psp.pfnCallback  =  PropPageCallbackProc;
    psp.lParam       =  (LPARAM) m_pVI;

    HPROPSHEETPAGE  hPage  =  CreatePropertySheetPage( &psp );

    if (hPage)
    {
        // Add our page to the Shell's property sheet...

        if (!pfnAddPageProc( hPage, lParam ))
        {
            DestroyPropertySheetPage( hPage );
            hPage = NULL;
        }
    }

    return hPage ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Page creation/destruction callback...

UINT  CALLBACK  PropPageCallbackProc ( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{
    if ( PSPCB_RELEASE == uMsg && ppsp->lParam)
        delete (CVersionInfo*) ppsp->lParam;

    return TRUE; // (so page gets created in case uMsg is PSPCB_CREATE)
}

//////////////////////////////////////////////////////////////////////////////////////////
// Initialize our property page...

BOOL  OnInitDialog ( HWND hwnd, LPARAM lParam )
{
    PROPSHEETPAGE*  ppsp  =  (PROPSHEETPAGE*) lParam;
    CVersionInfo*   pVI   =  (CVersionInfo*) ppsp->lParam;

    // Save our CVersionInfo pointer in the page so we can later retrieve it...

    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) pVI );

    // Now initialize all of our page's controls...

    CString strFileVersion = pVI->m_strFileVersionW;  // (convert to generic T type)
    SendDlgItemMessage( hwnd, IDC_FILE_VERSION_EDIT, WM_SETTEXT, 0, (LPARAM) (LPCTSTR) strFileVersion );

    if (!pVI->m_StringTableMap.GetSize())
        return FALSE; // (no StringTables?!)

    // (always use the first one in case there's more than one)

    CStringTable st = pVI->m_StringTableMap.GetValueAt(0);

    if (!st.m_StringsMap.GetSize())
        return FALSE; // (no Strings?!)

    // (process each String in the table...)

    CString strKey, strValue;

    WCHAR szModulePath[MAX_PATH];
    GetModuleFileNameW(_Module.GetResourceInstance(), szModulePath, MAX_PATH);
    TRACE(_T("*** OnInitDialog(): res module path: %ws\n"), szModulePath);

    for (int i=0; i < st.m_StringsMap.GetSize(); i++)
    {
        strKey   = st.m_StringsMap.GetKeyAt(i);
        strValue = st.m_StringsMap.GetValueAt(i);

        TRACE(_T("*** OnInitDialog(): string \"%ws\" = \"%ws\"\n"), strKey, strValue);

        if (strKey.CompareNoCase(_T( "FileDescription" )) == 0)
        {
            SendDlgItemMessage( hwnd, IDC_DESCRIPTION_EDIT, WM_SETTEXT, 0, (LPARAM) (LPCTSTR) strValue );
        }
        else if (strKey.CompareNoCase(_T( "LegalCopyright" )) == 0)
        {
            SendDlgItemMessage( hwnd, IDC_COPYRIGHT_EDIT,   WM_SETTEXT, 0, (LPARAM) (LPCTSTR) strValue );
        }
        else
        {
            const struct
            {
                TCHAR const *pszName;
                short idString;
            } vernames[] = {
                { TEXT("FileVersion"),              IDS_VN_FILEVERSION },
                { TEXT("Comments"),                 IDS_VN_COMMENTS },
                { TEXT("CompanyName"),              IDS_VN_COMPANYNAME },
                { TEXT("InternalName"),             IDS_VN_INTERNALNAME },
                { TEXT("LegalTrademarks"),  IDS_VN_LEGALTRADEMARKS },
                { TEXT("OriginalFilename"), IDS_VN_ORIGINALFILENAME },
                { TEXT("PrivateBuild"),             IDS_VN_PRIVATEBUILD },
                { TEXT("ProductName"),              IDS_VN_PRODUCTNAME },
                { TEXT("ProductVersion"),           IDS_VN_PRODUCTVERSION },
                { TEXT("SpecialBuild"),             IDS_VN_SPECIALBUILD }
            };

            for (int j = 0; j < ARRAYSIZE(vernames); j++)
            {
                if (strKey.CompareNoCase(vernames[j].pszName) == 0)
                {
                    TRACE(_T("*** OnInitDialog(): string for \"%ws\" = id %d\n"), strKey, vernames[i].idString);
                    strKey.LoadString(_Module.GetResourceInstance(), vernames[j].idString);
                    break;
                }
            }

            // Save this String's map position in the listbox item's data field...
            int nItem = (int)SendDlgItemMessage(hwnd, IDC_ITEM_NAME_LISTBOX, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strKey);
            SendDlgItemMessage(hwnd, IDC_ITEM_NAME_LISTBOX, LB_SETITEMDATA, (WPARAM)nItem, (LPARAM)i);
        }
    }

    // Auto-select the first item into view...

    if (SendDlgItemMessage( hwnd, IDC_ITEM_NAME_LISTBOX, LB_GETCOUNT,  0, 0 ) > 0)
    {
        SendDlgItemMessage( hwnd, IDC_ITEM_NAME_LISTBOX, LB_SETCURSEL, 0, 0 );

        // PROGRAMMING NOTE: deferring showing them the first item's value until now
        // is unfortunately mandatory, since the list box is sorted and item numbers
        // thus changed as new items were added. Waiting until now was the only way.

        int nStringNum = (int) SendDlgItemMessage( hwnd, IDC_ITEM_NAME_LISTBOX, LB_GETITEMDATA, (WPARAM) 0, 0 );

        if (nStringNum < 0 || nStringNum >= st.m_StringsMap.GetSize())
            return FALSE; // (bad value?!)

        // Retrieve this String's value...

        strValue = st.m_StringsMap.GetValueAt( nStringNum );

        // Show it to them...

        SendDlgItemMessage( hwnd, IDC_VALUE_EDIT, WM_SETTEXT, 0, (LPARAM) (LPCTSTR) strValue );
    }

    return FALSE;       // (default focus)
}

//////////////////////////////////////////////////////////////////////////////////////////
// Page's dialog procedure callback...

INT_PTR  CALLBACK  PropPageDlgProc ( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:

        return OnInitDialog ( hwnd, lParam );

    case WM_COMMAND:

        if (1
            && LOWORD( wParam ) == IDC_ITEM_NAME_LISTBOX
            && HIWORD( wParam ) == LBN_SELCHANGE
        )
        {
            // List box selection changed notification...

            HWND hwndLB = (HWND) lParam;
            int nLBItem = (int) SendMessage( hwndLB, LB_GETCURSEL, 0, 0 );
            if (nLBItem >= 0)
            {
                // Retrieve our pointer to our version information...

                CVersionInfo* pVI = (CVersionInfo*) GetWindowLongPtr( hwnd, GWLP_USERDATA );

                if (!pVI->m_StringTableMap.GetSize())
                    return FALSE; // (no StringTables?!)

                // (always use the first one in case there's more than one)

                CStringTable st = pVI->m_StringTableMap.GetValueAt(0);

                if (!st.m_StringsMap.GetSize())
                    return FALSE; // (no Strings?!)

                // Retrieve which StringTable String this item is for...

                int nStringNum = (int) SendMessage( hwndLB, LB_GETITEMDATA, (WPARAM) nLBItem, 0 );

                if (nStringNum < 0 || nStringNum >= st.m_StringsMap.GetSize())
                    return FALSE; // (bad value?!)

                // Retrieve this String's value...

                CString strValue = st.m_StringsMap.GetValueAt( nStringNum );

                // Show it to them...

                SendDlgItemMessage( hwnd, IDC_VALUE_EDIT, WM_SETTEXT, 0, (LPARAM) (LPCTSTR) strValue );
                return TRUE;
            }
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
